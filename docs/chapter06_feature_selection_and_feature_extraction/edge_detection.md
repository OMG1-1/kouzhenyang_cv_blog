---
status: new
---

# 边缘提取

!!! question "边缘是什么？"

    > 边缘也有正负之分：由暗到亮为正，由亮到暗为负。

    边缘是图像中不同区域之间的边界线，通常一个边缘图像是一个二值图像。

    边缘是图像局部区域亮度变化显著的部分，区域的灰度剖面一般可以看作是一个阶跃，即从低灰度值跳到高灰度值，边缘检测就是从图像中寻找这些阶跃。

边缘提取是图像处理和计算机视觉中的基本问题，主要是图像的灰度变化的度量、检测和定位。

## 边缘提取的目的

边缘检测的目的就是捕捉这些亮度急剧变化的区域，而这些区域通常是我们关注的。它是图像处理和计算机视觉中的基本问题，尤其是在特征提取领域，其目标是标识数字图像中亮度变化明显的点。

## 边缘提取的原理

边缘检测的原理主要是基于图像强度的突变（如灰度级的跳变），通过一阶导数或二阶导数来检测边缘。 (1) 大部分的边缘检测算法可以划分为两类：基于一阶导数和基于零穿越[^2]/零交叉[^2]的二阶导数。
{ .annotate }

1.  如果在此边缘部分求取一阶导数，就会看到极值的出现；而在一阶导数为极值的地方，二阶导数为 0，基于这个原理，就可以进行边缘检测。

---

!!! tip "知识回顾"

    ??? quote "梯度"

        [知识点重定向](/chapter03_math_basic/gradient.md#梯度)

    ??? quote "卷积"

        [知识点重定向](/chapter03_math_basic/gradient.md#梯度)

    ??? quote "高频信号与低频信号"

        图像中的高频信号和低频信号是指的频率。更具体来说，图像中的高频信号，也被称为高频分量，主要指的是图像强度（亮度/灰度）变化剧烈的地方，这通常就是我们常说的边缘（轮廓）。而图像中的低频信号，也被称为低频分量，主要是指的是图像强度（亮度/灰度）变换平缓的地方，通常是大片色块的区域。(1)
        {.annotate}

        1. 人眼对图像中的高频信号更为敏感，例如在一张白纸上有一行字，我们会直接聚焦在文字上，而不会太在意白纸本身，这里文字就是高频信号，而白纸就是低频信号。另外，图像的高低频是对图像各个位置之间强度变化的一种度量方法。如果一副图像的各个位置的强度大小相等，则图像只存在低频分量。

    ??? quote "图像平滑"

    ??? quote "图像锐化"

---

## 边缘提取算法

常见的边缘检测算法有 Zero Crossing 算子、Marr-Hildreth 算子、DoG 算子、Prewitt 算子、Sobel 算子和 Canny 算子等；这里重点将 Sobel 算子、Prewitt 算子、Canny 算子。

### Prewitt 算子

Prewitt 算子是一种一阶微分算子的边缘检测，利用像素点上下、左右邻点的灰度差，在边缘处达到极值检测边缘，去掉部分伪边缘，对噪声具有平滑作用。

原理是在图像空间利用两个方向模板 (1) 与图像进行邻域卷积来完成的
{ .annotate }

1.  这两个方向模板一个检测水平边缘，一个检测垂直边缘。

!!! note "Prewitt 算子模版"

    - 检测水平边缘：

    $$
    G_x =
    \begin{bmatrix}
    -1 & 0 & 1\\
    -1 & 0 & 1\\
    -1 & 0 & 1\\
    \end{bmatrix}
    $$

    - 检测垂直边缘：

    $$
    G_y =
    \begin{bmatrix}
    -1 & -1 & -1\\
    0 & 0 & 0\\
    1 & 1 & 1\\
    \end{bmatrix}
    $$

### Sobel 算子

> Soble 边缘检测: Soble 更强调了和边缘相邻的像素点对于边缘的影响。

Sobel 算子是典型的基于一阶导数的边缘检测算子，由于该算子中引入了类似局部平均的运算，因此对噪声具有平滑作用，能很好的消除噪声的影响。 Sobel 算子对于像素的位置的影响做了加权，因此与 Prewitt 算子相比效果更好。

!!! note "Sobel 算子模版"

    Sobel 算子包含两组 3x3 的矩阵，分别为横向及纵向模板，将之与图像作平面卷积，即可分别得出横向及纵向的亮度差分近似值。实际使用中，常用如下两个模板来检测图像边缘:

    > 水平梯度卷积核(Horizontal Gradient Convolution Kernel)

    $$
    \begin{bmatrix}
    -1 & 0 & 1 \\
    -2 & 0 & 2 \\
    -1 & 0 & 1
    \end{bmatrix}
    $$

    > 垂直梯度卷积核(Vertical Gradient Convolution Kernel)

    $$
    \begin{bmatrix}
    -1 & -2 & -1 \\
    0 & 0 & 0 \\
    1 & 2 & 1
    \end{bmatrix}
    $$

!!! note "Sobel 实现"

    ```python title="Soble 边缘检测"
    import cv2
    import numpy as np
    import matplotlib.pyplot as plt

    # 读取图像
    image = cv2.imread('input.jpg', cv2.IMREAD_GRAYSCALE)

    # 使用Sobel算子进行边缘检测
    sobel_x = cv2.Sobel(image, cv2.CV_64F, 1, 0, ksize=3)
    sobel_y = cv2.Sobel(image, cv2.CV_64F, 0, 1, ksize=3)

    # 计算梯度幅值和方向
    gradient_magnitude = np.sqrt(sobel_x__2 + sobel_y__2)
    gradient_direction = np.arctan2(sobel_y, sobel_x) * (180 / np.pi)

    # matplotlib显示结果
    plt.figure()
    plt.subplot(1, 3, 1)
    plt.imshow(image, cmap='gray')
    plt.title('Original Image')

    plt.subplot(1, 3, 2)
    plt.imshow(gradient_magnitude, cmap='gray')
    plt.title('Gradient Magnitude')

    plt.subplot(1, 3, 3)
    plt.imshow(gradient_direction, cmap='gray')
    plt.title('Gradient Direction')

    plt.show()
    ```

!!! failure "Sobel 算子的缺点"

    Sobel 算子对噪声比较敏感，在图像中加噪声时，Sobel 算子检测出来的边缘会不准确。

    Sobel算子并没有将图像的主题与背景严格地区分开来，换言之就是Sobel算子并没有基于图像灰度进行处理，由于Sobel算子并没有严格地模拟人的视觉生理特征，所以提取的图像轮廓有时并不能令人满意。

### Canny 算子

Canny 算子则是一种非常优秀的边缘检测算法，它是基于梯度幅值和非极大值抑制的边缘检测方法。

Canny 算法是一种被广泛应用于边缘检测的标准算法，由计算机科学家 John F. Canny 于 1986 年提出。它的主要目标是找到一个最优的边缘检测解或找寻一幅图像中灰度强度变化最强的位置。

Canny 算子是一种基于梯度的边缘检测算法，通过计算图像中像素点的梯度大小和方向来工作。(1)
{ .annotate }

1.  具体来说，它首先使用高斯滤波器来去除图像中的噪声，然后计算图像的梯度强度和方向，最后通过非极大值抑制和双阈值处理来检测和强化边缘。

这种算法被认为是目前理论上最完善的一种边缘检测方法，因为它能够在抗噪声干扰和精确定位之间寻求最佳折中方案。Canny 算子的应用非常广泛，例如在物体识别领域，如机器人视觉等，都有大量的应用实例。

#### 原理

#### 步骤

1.  对图像进行灰度化
2.  对图像进行高斯滤波: 根据待滤波的像素点及其邻域点的灰度值按照一定的参数规则进行加权平均。这样可以有效滤去理想图像中叠加的高频噪声。
3.  计算梯度幅度图像和梯度方向图像：检测图像中的水平、垂直和对角边缘(如 Prewitt，Sobel 算子等)。(1)
    { .annotate }

    1. 这一步是核心步骤，通过计算图像中每个像素点的梯度大小和方向来确定边缘。

4.  对梯度幅值进行非极大值抑制: 通俗意义上是指寻找像素点局部最大值，将非极大值点所对应的灰度值置为 0，这样可以剔除掉一大部分非边缘的点。(1)
    { .annotate }

    1. 这一步是为了消除假边缘，提高边缘检测的准确性。

5.  使用双阈值处理和连通性来检测和连接边缘：用双阈值算法检测和连接边缘。(1)
    { .annotate }

    1. 这一步是确定真正的边缘，并进行连接，得到完整的边缘信息。

#### 相关概念

???+ note "高斯平滑"

    高斯平滑水平和垂直方向呈现高斯分布，更突出了中心点在像素平滑后的权重，相比于均值滤波而言，有着更好的平滑效果。

    $$
    G(x) = \frac{1}{\sqrt{2\pi} \sigma}e^{-\frac{x^2}{2\sigma^2}}
    $$

    $$
    G(x,y) = \frac{1}{2\pi\sigma^2}e^{-\frac{(x^2+y^2)}{2\sigma^2}}
    $$

    高斯卷积核大小会影响 Canny 检测器的性能：

    - 卷积核越大，检测器对噪声的敏感度越低，但边缘定位精度也越低。
    - 卷积核越小，检测器对噪声的敏感度越高，但边缘定位精度越高。

    一般情况下，卷积核大小为 5×5 比较合适。

    [高斯噪声的详细介绍](../chapter05_image_filter/image_noise.md#高斯噪声)

!!! Note "非极大值抑制"

    非极大值抑制（Non-Maximum Suppression，NMS）是一种计算机视觉领域的技术，用于处理如边缘检测、人脸检测和目标检测等问题(1)。它的主要目标是从一组可能的输出结果中选择最佳的一个或几个。
    { .annotate }

    1. 广泛应用于各种任务中，包括目标跟踪、3D 重建、纹理分析等。

    > 原理

    通俗意义上是指寻找像素点局部最大值，将非极大值点所对应的灰度值置为0，这样可以剔除掉一大部分非边缘的点。

    1.  将当前像素的梯度强度与沿正负梯度方向上的两个像素进行比较。
    2. 如果当前像素的梯度强度与另外两个像素相比最大，则该像素点保留为边缘点，否则该像素点将被抑制(灰度值置为0)

    ![image_nms](./edge_detection.assets/image_nms.png)

    > 实际应用-目标检测

    进行目标检测任务时，由于同一目标可能存在于图像中的多个位置，并产生大量的候选框，这些候选框之间可能会存在重叠。而非极大值抑制算法就是通过比较每个边界框的置信度得分，保留最高分的边界框，抑制（即删除）低分的冗余边界框.

    ![Non-Maximum Suppression](edge_detection.assets/Non-Maximum_suppression.jpg)

    > 实际应用-梯度计算

    非极大值抑制也用在了梯度计算中。在边缘检测的过程中，例如 Canny 算子，会首先计算像素点的梯度大小和方向。为了找到真正的边缘点，需要判断该点的灰度值是否在其邻域内为最大。如果不是最大值，那么可以将其视为非边缘点并抑制掉。

!!! Note "双阈值算法"

    双阈值算法是一种在边缘检测中频繁使用的方法，它主要针对图像的灰度值进行操作。具体来说，对于两个设定的阈值 thresh1 和 thresh2（其中 thresh1 < thresh2），该算法会将大于 thresh1 且小于 thresh2 的灰度值设定为最大值，而其他灰度值则被设为 0。

    在 Canny 算法中，双阈值方法发挥了重要的作用。

    __首先，它会选取两个阈值（即低阈值和高阈值）；当像素的灰度值大于低阈值时，该像素点被视为可能存在的边缘；若像素的灰度值小于高阈值，那么这个像素点则会被确定为噪声并剔除。__

    此外，介于这两个阈值之间的灰度值将被认定为弱边缘。

    通过这种方式，Canny 算法能够有效地检测并连接图像中的边缘，从而得到较为精确的结果。

### Zero Crossing 算子

通过检测 Laplacian 算子的零交叉来检测边缘的。

### Marr-Hildreth 算子

一种基于高斯滤波和 Laplacian 算子的边缘检测算子。

### DoG 算子

DoG 算子是一种多尺度边缘检测算子，通过检测图像中的高斯滤波与拉普拉斯滤波的差值来检测边缘。

### Laplacian (拉普拉斯）算法

一种二阶导数的边缘检测算法，它通过计算图像中每个像素点的二阶导数来确定边缘。

## 总结

总的来说，边缘检测的目的是标识数字图像中亮度变化明显的点，这些变化通常反映了图像的重要属性和事件，如深度上的不连续、表面方向不连续和物质属性变化等。这两种方法都是为了更准确地找到这些亮度变化明显的点，从而更好地完成边缘检测任务。

[^1]: 零穿越是一种基于二阶导数的方法，通过寻找图像二阶导数的零穿越点来确定边界。这通常涉及到 Laplacian 过零点或非线性差分表示的过零点。具体来说，一阶导数的局部最大值对应于二阶导数的零交叉点。因此，通过找出图像强度的二阶导数的零交叉点，我们可以精确地定位到边缘点。
[^2]: 零交叉则是另一种方法，其主要思想是检测两个相邻像素点的像素值是否异号。当滤波后的图像在某个像素点的左右、上下或两个对角位置的差值的绝对值超过了设定的阈值时，我们就可以认为该像素点是一个边缘点。为了减少噪声的影响，在进行零交叉判断时，通常会加上一个阈值条件。
